# Car Accident Severity Prediction Model For City of Seattle

Jai Vigneshwar



## Introduction
<p align = "justify">
Car accidents are a leading cause of injuries. Over 5.6 million car accidents were reported in the United States in 2012. Of these, over 30,000 were fatal, and another 1.6 million involved other injuries. The damage they leave behind can be immense. The economic cost of car accidents is estimated to be $277 billion each year, or around $897 for every person living in the United States. While car accident injuries can vary from person to person and from crash to crash. However, if we can build a model to predict the severity of a car accident, that would avoid a lot of unnecessary accidents and injuries, even deaths. Therefore, the Seattle government is planning to use this model that alert drivers, health systems, and police to remind them to pay more attention to critical situations.
Imagine a scenario that if there is a rainy day and you are planning to drive to another city. The model can predict the severity of the accident severity based on the condition of traffic, report the accident location, weather conditions, and other factors that provide you more options for traveling, reschedule, or drive more carefully. However, distraction and not paying enough attention while driving are important reasons that cause car accidents. This model will alert drivers driving more carefully and can be prevented by enacting harsher regulations.
The target audience of this project is the Seattle government, police, rescue groups, and drivers. This model and its prediction will provide advice for decision making and prevent unnecessary accidents and injuries for the city of Seattle. </p>

## Data understanding:
<p align = "justify">
In my consideration, I will drop some non-critical and indecisive attributes. The following features which I choose to remain for building model and prediction.
 <ul>
<li> UNDERINFL which means whether or not the driver was under the influence.</li>
<li> WEATHER which represents the weather condition while the collision occurs.</li>
<li> ROADCOND which represents the road conditions while the collision occurs.</li>
<li> LIGHTCOND which represents the light conditions while the collision occurs.</li> </ul>
However, the existent data contains null values in some records, the data has to be preprocessed before further processing and analyzing.</p>



## Methodology 

### Phenomena of Interest
<p align = "justify">
The light intensity near the point of entry and the IR beam state at the point of entry or exit are the phenomena of interest.

#### Visible light intensity
<p align = "justify">
The visible light spectrum is a part of the electromagnetic spectrum that can be viewd by the human eye. Wavelenghts from 380 to 700 nanometers are visible and this is called the visible light spectrum.[3]
<p align = "center">
<img src="https://github.com/SadhanaSai/12740-COVIDOccupancy/blob/main/Visible.png" width="400" height="100"></p>
<p align = "center">Fig1: Visible light spectrum[3]</p>



#### Infrared Radiation
<p align = "justify">
Infrared radiation is a part of the electromagnetic spectrum. In the electromagnetic radiation spectrum, it lies between 780 nm and 1 mm, above the visible red light wavelength.[3]
<p align = "center">
<img src="https://github.com/SadhanaSai/12740-COVIDOccupancy/blob/main/Spectrum.png"></p>
<p align = "center">Fig2: Electromagnetic spectrum[3]</p>

## Sensors Used

### Photosensitive Light Sensor Module


#### Physical principles
<p align = "justify">
The principle of the photoresistor is based on the internal photoelectric effect. These light dependet resistors are formed by mounting electrode leads at both ends of the semiconductor photosensitive material. These are encapsulated in a tube case with a transparent window. The two electrodes are often made into a comb shape in order to increase sensitivity.  </p>
<p align = "justify">
As elaborated in Photoresistor Basics: Types, Principles and Applications: "After the incident light disappears, the electron-hole pairs generated by the photon excitation will recombine, and the resistance of the photoresistor will return to its original value. When a voltage is applied to the metal electrodes at both ends of the photoresistor, a current passes through it. When the photoresistor is irradiated by the light with a certain wavelength, the current will increase with the light intensity, thereby achieving photoelectric conversion."[5] The photoresistor is a purely resistive device and can be used with DC and AC.</p>

The below image shows the LDR.
<p align = "center">
<img src="https://github.com/SadhanaSai/12740-COVIDOccupancy/blob/main/ldr.jpg"></p>
<p align = "center">Fig3: Photoresistor[5]</p>


#### Sensor characteristics

Input voltage: 3.3V to 5V

LDR module 4 PIN

Output: Digital Switch I/O or Anlog Voltage (For this project Digital Switch I/O was used)

Range, Sensitivity: Adjustable

PCB Dimensions: 3.3 cm x 1.4 cm

Weight: 4g

Additional feature: Indicator Light on sensor [6]

<p align = "center">
<img src="https://github.com/SadhanaSai/12740-COVIDOccupancy/blob/main/LS.jpg" width="200" height="200"></p>
<p align = "center">Fig4: Photosensitive Light Sensor Module[6]</p>

#### Applications
<p align = "justify">
This sensor could be used for outdoor lights, lift lobby and common staircases. Also, it could be used in shopping mall or used as garden lights.</p>

#### Signal characteristics
<p align = "justify">
The Photosensitive Light sensor module has to modes of outputs. One being the Digital switch I/O, and the Analog voltage output. In this case I had used the digital switch output signals to identify the state of the sensor. </p>

### Breakbeam sensor 

#### Physical principles

<p align = "justify">
Break beam sensors come under the class of Photoelectric Sensors. They use pulse modulated light for contact less sensing. In this case IR is emitted by the sensor.[4]</p>
<p align = "justify">
Pulse modulated light is light that is emitted repeatedly at fixed intervals. 
Effects of external light interference are removed and thus objects at a distance can easily be detected. The below image shows the kind of light produced by the emitter.[4]</p>

<p align = "center">
<img src="https://github.com/SadhanaSai/12740-COVIDOccupancy/blob/main/pml.gif" ></p>
<p align = "center">Fig5: Pulse modulated light [4]</p>
<p align = "justify">
The Emitter and Receiver are installed opposite each other. The receives the light produced by the emitter. </p>

<p align = "center">
<img src="https://github.com/SadhanaSai/12740-COVIDOccupancy/blob/main/bb.jpg" ></p>
<p align = "center">Fig6: Break beam sensors working[4]</p>
<p align = "justify">
An object passing between the Emitter and Receiver interrupts the emitted light. This obstruction to the light is used to detect an object.</p>

<p align = "center">
<img src="https://github.com/SadhanaSai/12740-COVIDOccupancy/blob/main/egbb.gif" ></p>
<p align = "center">Fig7: Break beam object sensing[4]</p>
<p align = "justify">
The main working principles are the rectilinear propagation of light and its reflective properties.[4]</p>






### Logic
<p align = "justify">
If the Light sensor is triggered and then the break beam sensor is triggered, a person has entered the room.</p>
<p align = "justify">
If the Break beam sensor signal is first triggered and then the lightsensor is triggered, a person has exited the room. Using this as the base logic, a counter was created. This count was then used to trigger the LED once the maximum occupancy is reached. </p>

<pre>
<code>
 if GPIO.input(LIGHT_PIN):
                        time.sleep(1)
                        countl = countl +1
                        print ("LS count",countl)
                        if countl >countb:
                                Count = min(max(Count +1, 0),10)
                                print (Count)
                                time.sleep(1)
                                pass
                else:
                        pass
                if  GPIO.input(BEAM_PIN):
                        pass
                else:
                        time.sleep(1)
                        countb = countb+1
                        print ("BB count",countb)
                        pass
                        if countb >countl:
                                Count = max(Count -1, 0)
                                print (Count)
                                time.sleep(1)
                                pass
                        elif countl ==countb:
                                Count = Count
                                pass
                if Count>3:
                        print ("Don't enter")
                        GPIO.output(18,GPIO.HIGH)
                        time.sleep(1)
                        pass
 </code>
 </pre>

## Experiments and Results


## Appendix
KNN Confusion Matrix
<p align = "center">
<img src="https://github.com/SadhanaSai/12740-COVIDOccupancy/blob/main/results.jpg"></p>
Decision Tree Confusion Matrix
<p align = "center">
<img src="https://github.com/SadhanaSai/12740-COVIDOccupancy/blob/main/results.jpg"></p>
Logistic Regression Confusion Matrix
<p align = "center">
<img src="https://github.com/SadhanaSai/12740-COVIDOccupancy/blob/main/results.jpg"></p>
SVM Confusion Matrix
<p align = "center">
<img src="https://github.com/SadhanaSai/12740-COVIDOccupancy/blob/main/results.jpg"></p>
